{"version":3,"file":"dist-DRYGEemB.js","names":[],"sources":["../../.pnpm/hookable@5.5.3/node_modules/hookable/dist/index.mjs","../../.pnpm/birpc@2.9.0/node_modules/birpc/dist/index.mjs"],"sourcesContent":["function flatHooks(configHooks, hooks = {}, parentName) {\n  for (const key in configHooks) {\n    const subHook = configHooks[key];\n    const name = parentName ? `${parentName}:${key}` : key;\n    if (typeof subHook === \"object\" && subHook !== null) {\n      flatHooks(subHook, hooks, name);\n    } else if (typeof subHook === \"function\") {\n      hooks[name] = subHook;\n    }\n  }\n  return hooks;\n}\nfunction mergeHooks(...hooks) {\n  const finalHooks = {};\n  for (const hook of hooks) {\n    const flatenHook = flatHooks(hook);\n    for (const key in flatenHook) {\n      if (finalHooks[key]) {\n        finalHooks[key].push(flatenHook[key]);\n      } else {\n        finalHooks[key] = [flatenHook[key]];\n      }\n    }\n  }\n  for (const key in finalHooks) {\n    if (finalHooks[key].length > 1) {\n      const array = finalHooks[key];\n      finalHooks[key] = (...arguments_) => serial(array, (function_) => function_(...arguments_));\n    } else {\n      finalHooks[key] = finalHooks[key][0];\n    }\n  }\n  return finalHooks;\n}\nfunction serial(tasks, function_) {\n  return tasks.reduce(\n    (promise, task) => promise.then(() => function_(task)),\n    Promise.resolve()\n  );\n}\nconst defaultTask = { run: (function_) => function_() };\nconst _createTask = () => defaultTask;\nconst createTask = typeof console.createTask !== \"undefined\" ? console.createTask : _createTask;\nfunction serialTaskCaller(hooks, args) {\n  const name = args.shift();\n  const task = createTask(name);\n  return hooks.reduce(\n    (promise, hookFunction) => promise.then(() => task.run(() => hookFunction(...args))),\n    Promise.resolve()\n  );\n}\nfunction parallelTaskCaller(hooks, args) {\n  const name = args.shift();\n  const task = createTask(name);\n  return Promise.all(hooks.map((hook) => task.run(() => hook(...args))));\n}\nfunction serialCaller(hooks, arguments_) {\n  return hooks.reduce(\n    (promise, hookFunction) => promise.then(() => hookFunction(...arguments_ || [])),\n    Promise.resolve()\n  );\n}\nfunction parallelCaller(hooks, args) {\n  return Promise.all(hooks.map((hook) => hook(...args || [])));\n}\nfunction callEachWith(callbacks, arg0) {\n  for (const callback of [...callbacks]) {\n    callback(arg0);\n  }\n}\n\nclass Hookable {\n  constructor() {\n    this._hooks = {};\n    this._before = void 0;\n    this._after = void 0;\n    this._deprecatedMessages = void 0;\n    this._deprecatedHooks = {};\n    this.hook = this.hook.bind(this);\n    this.callHook = this.callHook.bind(this);\n    this.callHookWith = this.callHookWith.bind(this);\n  }\n  hook(name, function_, options = {}) {\n    if (!name || typeof function_ !== \"function\") {\n      return () => {\n      };\n    }\n    const originalName = name;\n    let dep;\n    while (this._deprecatedHooks[name]) {\n      dep = this._deprecatedHooks[name];\n      name = dep.to;\n    }\n    if (dep && !options.allowDeprecated) {\n      let message = dep.message;\n      if (!message) {\n        message = `${originalName} hook has been deprecated` + (dep.to ? `, please use ${dep.to}` : \"\");\n      }\n      if (!this._deprecatedMessages) {\n        this._deprecatedMessages = /* @__PURE__ */ new Set();\n      }\n      if (!this._deprecatedMessages.has(message)) {\n        console.warn(message);\n        this._deprecatedMessages.add(message);\n      }\n    }\n    if (!function_.name) {\n      try {\n        Object.defineProperty(function_, \"name\", {\n          get: () => \"_\" + name.replace(/\\W+/g, \"_\") + \"_hook_cb\",\n          configurable: true\n        });\n      } catch {\n      }\n    }\n    this._hooks[name] = this._hooks[name] || [];\n    this._hooks[name].push(function_);\n    return () => {\n      if (function_) {\n        this.removeHook(name, function_);\n        function_ = void 0;\n      }\n    };\n  }\n  hookOnce(name, function_) {\n    let _unreg;\n    let _function = (...arguments_) => {\n      if (typeof _unreg === \"function\") {\n        _unreg();\n      }\n      _unreg = void 0;\n      _function = void 0;\n      return function_(...arguments_);\n    };\n    _unreg = this.hook(name, _function);\n    return _unreg;\n  }\n  removeHook(name, function_) {\n    if (this._hooks[name]) {\n      const index = this._hooks[name].indexOf(function_);\n      if (index !== -1) {\n        this._hooks[name].splice(index, 1);\n      }\n      if (this._hooks[name].length === 0) {\n        delete this._hooks[name];\n      }\n    }\n  }\n  deprecateHook(name, deprecated) {\n    this._deprecatedHooks[name] = typeof deprecated === \"string\" ? { to: deprecated } : deprecated;\n    const _hooks = this._hooks[name] || [];\n    delete this._hooks[name];\n    for (const hook of _hooks) {\n      this.hook(name, hook);\n    }\n  }\n  deprecateHooks(deprecatedHooks) {\n    Object.assign(this._deprecatedHooks, deprecatedHooks);\n    for (const name in deprecatedHooks) {\n      this.deprecateHook(name, deprecatedHooks[name]);\n    }\n  }\n  addHooks(configHooks) {\n    const hooks = flatHooks(configHooks);\n    const removeFns = Object.keys(hooks).map(\n      (key) => this.hook(key, hooks[key])\n    );\n    return () => {\n      for (const unreg of removeFns.splice(0, removeFns.length)) {\n        unreg();\n      }\n    };\n  }\n  removeHooks(configHooks) {\n    const hooks = flatHooks(configHooks);\n    for (const key in hooks) {\n      this.removeHook(key, hooks[key]);\n    }\n  }\n  removeAllHooks() {\n    for (const key in this._hooks) {\n      delete this._hooks[key];\n    }\n  }\n  callHook(name, ...arguments_) {\n    arguments_.unshift(name);\n    return this.callHookWith(serialTaskCaller, name, ...arguments_);\n  }\n  callHookParallel(name, ...arguments_) {\n    arguments_.unshift(name);\n    return this.callHookWith(parallelTaskCaller, name, ...arguments_);\n  }\n  callHookWith(caller, name, ...arguments_) {\n    const event = this._before || this._after ? { name, args: arguments_, context: {} } : void 0;\n    if (this._before) {\n      callEachWith(this._before, event);\n    }\n    const result = caller(\n      name in this._hooks ? [...this._hooks[name]] : [],\n      arguments_\n    );\n    if (result instanceof Promise) {\n      return result.finally(() => {\n        if (this._after && event) {\n          callEachWith(this._after, event);\n        }\n      });\n    }\n    if (this._after && event) {\n      callEachWith(this._after, event);\n    }\n    return result;\n  }\n  beforeEach(function_) {\n    this._before = this._before || [];\n    this._before.push(function_);\n    return () => {\n      if (this._before !== void 0) {\n        const index = this._before.indexOf(function_);\n        if (index !== -1) {\n          this._before.splice(index, 1);\n        }\n      }\n    };\n  }\n  afterEach(function_) {\n    this._after = this._after || [];\n    this._after.push(function_);\n    return () => {\n      if (this._after !== void 0) {\n        const index = this._after.indexOf(function_);\n        if (index !== -1) {\n          this._after.splice(index, 1);\n        }\n      }\n    };\n  }\n}\nfunction createHooks() {\n  return new Hookable();\n}\n\nconst isBrowser = typeof window !== \"undefined\";\nfunction createDebugger(hooks, _options = {}) {\n  const options = {\n    inspect: isBrowser,\n    group: isBrowser,\n    filter: () => true,\n    ..._options\n  };\n  const _filter = options.filter;\n  const filter = typeof _filter === \"string\" ? (name) => name.startsWith(_filter) : _filter;\n  const _tag = options.tag ? `[${options.tag}] ` : \"\";\n  const logPrefix = (event) => _tag + event.name + \"\".padEnd(event._id, \"\\0\");\n  const _idCtr = {};\n  const unsubscribeBefore = hooks.beforeEach((event) => {\n    if (filter !== void 0 && !filter(event.name)) {\n      return;\n    }\n    _idCtr[event.name] = _idCtr[event.name] || 0;\n    event._id = _idCtr[event.name]++;\n    console.time(logPrefix(event));\n  });\n  const unsubscribeAfter = hooks.afterEach((event) => {\n    if (filter !== void 0 && !filter(event.name)) {\n      return;\n    }\n    if (options.group) {\n      console.groupCollapsed(event.name);\n    }\n    if (options.inspect) {\n      console.timeLog(logPrefix(event), event.args);\n    } else {\n      console.timeEnd(logPrefix(event));\n    }\n    if (options.group) {\n      console.groupEnd();\n    }\n    _idCtr[event.name]--;\n  });\n  return {\n    /** Stop debugging and remove listeners */\n    close: () => {\n      unsubscribeBefore();\n      unsubscribeAfter();\n    }\n  };\n}\n\nexport { Hookable, createDebugger, createHooks, flatHooks, mergeHooks, parallelCaller, serial, serialCaller };\n","const TYPE_REQUEST = \"q\";\nconst TYPE_RESPONSE = \"s\";\nconst DEFAULT_TIMEOUT = 6e4;\nfunction defaultSerialize(i) {\n  return i;\n}\nconst defaultDeserialize = defaultSerialize;\nconst { clearTimeout, setTimeout } = globalThis;\nconst random = Math.random.bind(Math);\nfunction createBirpc($functions, options) {\n  const {\n    post,\n    on,\n    off = () => {\n    },\n    eventNames = [],\n    serialize = defaultSerialize,\n    deserialize = defaultDeserialize,\n    resolver,\n    bind = \"rpc\",\n    timeout = DEFAULT_TIMEOUT\n  } = options;\n  let $closed = false;\n  const _rpcPromiseMap = /* @__PURE__ */ new Map();\n  let _promiseInit;\n  let rpc;\n  async function _call(method, args, event, optional) {\n    if ($closed)\n      throw new Error(`[birpc] rpc is closed, cannot call \"${method}\"`);\n    const req = { m: method, a: args, t: TYPE_REQUEST };\n    if (optional)\n      req.o = true;\n    const send = async (_req) => post(serialize(_req));\n    if (event) {\n      await send(req);\n      return;\n    }\n    if (_promiseInit) {\n      try {\n        await _promiseInit;\n      } finally {\n        _promiseInit = void 0;\n      }\n    }\n    let { promise, resolve, reject } = createPromiseWithResolvers();\n    const id = nanoid();\n    req.i = id;\n    let timeoutId;\n    async function handler(newReq = req) {\n      if (timeout >= 0) {\n        timeoutId = setTimeout(() => {\n          try {\n            const handleResult = options.onTimeoutError?.call(rpc, method, args);\n            if (handleResult !== true)\n              throw new Error(`[birpc] timeout on calling \"${method}\"`);\n          } catch (e) {\n            reject(e);\n          }\n          _rpcPromiseMap.delete(id);\n        }, timeout);\n        if (typeof timeoutId === \"object\")\n          timeoutId = timeoutId.unref?.();\n      }\n      _rpcPromiseMap.set(id, { resolve, reject, timeoutId, method });\n      await send(newReq);\n      return promise;\n    }\n    try {\n      if (options.onRequest)\n        await options.onRequest.call(rpc, req, handler, resolve);\n      else\n        await handler();\n    } catch (e) {\n      if (options.onGeneralError?.call(rpc, e) !== true)\n        throw e;\n      return;\n    } finally {\n      clearTimeout(timeoutId);\n      _rpcPromiseMap.delete(id);\n    }\n    return promise;\n  }\n  const $call = (method, ...args) => _call(method, args, false);\n  const $callOptional = (method, ...args) => _call(method, args, false, true);\n  const $callEvent = (method, ...args) => _call(method, args, true);\n  const $callRaw = (options2) => _call(options2.method, options2.args, options2.event, options2.optional);\n  const builtinMethods = {\n    $call,\n    $callOptional,\n    $callEvent,\n    $callRaw,\n    $rejectPendingCalls,\n    get $closed() {\n      return $closed;\n    },\n    get $meta() {\n      return options.meta;\n    },\n    $close,\n    $functions\n  };\n  rpc = new Proxy({}, {\n    get(_, method) {\n      if (Object.prototype.hasOwnProperty.call(builtinMethods, method))\n        return builtinMethods[method];\n      if (method === \"then\" && !eventNames.includes(\"then\") && !(\"then\" in $functions))\n        return void 0;\n      const sendEvent = (...args) => _call(method, args, true);\n      if (eventNames.includes(method)) {\n        sendEvent.asEvent = sendEvent;\n        return sendEvent;\n      }\n      const sendCall = (...args) => _call(method, args, false);\n      sendCall.asEvent = sendEvent;\n      return sendCall;\n    }\n  });\n  function $close(customError) {\n    $closed = true;\n    _rpcPromiseMap.forEach(({ reject, method }) => {\n      const error = new Error(`[birpc] rpc is closed, cannot call \"${method}\"`);\n      if (customError) {\n        customError.cause ??= error;\n        return reject(customError);\n      }\n      reject(error);\n    });\n    _rpcPromiseMap.clear();\n    off(onMessage);\n  }\n  function $rejectPendingCalls(handler) {\n    const entries = Array.from(_rpcPromiseMap.values());\n    const handlerResults = entries.map(({ method, reject }) => {\n      if (!handler) {\n        return reject(new Error(`[birpc]: rejected pending call \"${method}\".`));\n      }\n      return handler({ method, reject });\n    });\n    _rpcPromiseMap.clear();\n    return handlerResults;\n  }\n  async function onMessage(data, ...extra) {\n    let msg;\n    try {\n      msg = deserialize(data);\n    } catch (e) {\n      if (options.onGeneralError?.call(rpc, e) !== true)\n        throw e;\n      return;\n    }\n    if (msg.t === TYPE_REQUEST) {\n      const { m: method, a: args, o: optional } = msg;\n      let result, error;\n      let fn = await (resolver ? resolver.call(rpc, method, $functions[method]) : $functions[method]);\n      if (optional)\n        fn ||= () => void 0;\n      if (!fn) {\n        error = new Error(`[birpc] function \"${method}\" not found`);\n      } else {\n        try {\n          result = await fn.apply(bind === \"rpc\" ? rpc : $functions, args);\n        } catch (e) {\n          error = e;\n        }\n      }\n      if (msg.i) {\n        if (error && options.onError)\n          options.onError.call(rpc, error, method, args);\n        if (error && options.onFunctionError) {\n          if (options.onFunctionError.call(rpc, error, method, args) === true)\n            return;\n        }\n        if (!error) {\n          try {\n            await post(serialize({ t: TYPE_RESPONSE, i: msg.i, r: result }), ...extra);\n            return;\n          } catch (e) {\n            error = e;\n            if (options.onGeneralError?.call(rpc, e, method, args) !== true)\n              throw e;\n          }\n        }\n        try {\n          await post(serialize({ t: TYPE_RESPONSE, i: msg.i, e: error }), ...extra);\n        } catch (e) {\n          if (options.onGeneralError?.call(rpc, e, method, args) !== true)\n            throw e;\n        }\n      }\n    } else {\n      const { i: ack, r: result, e: error } = msg;\n      const promise = _rpcPromiseMap.get(ack);\n      if (promise) {\n        clearTimeout(promise.timeoutId);\n        if (error)\n          promise.reject(error);\n        else\n          promise.resolve(result);\n      }\n      _rpcPromiseMap.delete(ack);\n    }\n  }\n  _promiseInit = on(onMessage);\n  return rpc;\n}\nconst cacheMap = /* @__PURE__ */ new WeakMap();\nfunction cachedMap(items, fn) {\n  return items.map((i) => {\n    let r = cacheMap.get(i);\n    if (!r) {\n      r = fn(i);\n      cacheMap.set(i, r);\n    }\n    return r;\n  });\n}\nfunction createBirpcGroup(functions, channels, options = {}) {\n  const getChannels = () => typeof channels === \"function\" ? channels() : channels;\n  const getClients = (channels2 = getChannels()) => cachedMap(channels2, (s) => createBirpc(functions, { ...options, ...s }));\n  function _boardcast(method, args, event, optional) {\n    const clients = getClients();\n    return Promise.all(clients.map((c) => c.$callRaw({ method, args, event, optional })));\n  }\n  function $call(method, ...args) {\n    return _boardcast(method, args, false);\n  }\n  function $callOptional(method, ...args) {\n    return _boardcast(method, args, false, true);\n  }\n  function $callEvent(method, ...args) {\n    return _boardcast(method, args, true);\n  }\n  const broadcastBuiltin = {\n    $call,\n    $callOptional,\n    $callEvent\n  };\n  const broadcastProxy = new Proxy({}, {\n    get(_, method) {\n      if (Object.prototype.hasOwnProperty.call(broadcastBuiltin, method))\n        return broadcastBuiltin[method];\n      const client = getClients();\n      const callbacks = client.map((c) => c[method]);\n      const sendCall = (...args) => {\n        return Promise.all(callbacks.map((i) => i(...args)));\n      };\n      sendCall.asEvent = async (...args) => {\n        await Promise.all(callbacks.map((i) => i.asEvent(...args)));\n      };\n      return sendCall;\n    }\n  });\n  function updateChannels(fn) {\n    const channels2 = getChannels();\n    fn?.(channels2);\n    return getClients(channels2);\n  }\n  getClients();\n  return {\n    get clients() {\n      return getClients();\n    },\n    functions,\n    updateChannels,\n    broadcast: broadcastProxy,\n    /**\n     * @deprecated use `broadcast`\n     */\n    // @ts-expect-error deprecated\n    boardcast: broadcastProxy\n  };\n}\nfunction createPromiseWithResolvers() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return { promise, resolve, reject };\n}\nconst urlAlphabet = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nfunction nanoid(size = 21) {\n  let id = \"\";\n  let i = size;\n  while (i--)\n    id += urlAlphabet[random() * 64 | 0];\n  return id;\n}\n\nexport { DEFAULT_TIMEOUT, cachedMap, createBirpc, createBirpcGroup };\n"],"x_google_ignoreList":[0,1],"mappings":"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"}